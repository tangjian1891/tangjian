# 浏览器相关

> (抛开加载完成的先后顺序)无论是css还是js，请求的发出都是并发的，但是资源解析执行时，一定是根据顺序来的(而且阻塞)，后面的资源即使先到也要等前面的资源完全拿到并且解析完成。

### css加载

css脚本是并发请求(页面上有多少就并发多少)

(加载时)不会阻塞DOM解析生成DOM树。（但是由于不能生成rendertree，所以页面还是白屏）

(加载时)会阻塞后续js执行(即使js资源已经加载完成)

#### rel(relationship)

所有没有rel属性的link标签不会发出请求

preload与prefetch

preload:预加载，但不会阻塞渲染引擎。(但是从另外一个角度看，会占用请求数与网速资源)

prefetch：预请求，在空闲时才会发出请求加载资源，所以不会抢占必要资源的请求(符合实际业务情况,且能加载的资源包括style,script,video等)

rel设置为preload与prefetch后，还需要设置as属性确定资源类型.

### js加载

普通的script脚本加载时会阻塞渲染引擎,执行时也会阻塞渲染引擎。

script脚本是并发请求(页面上有多个就并发多少个)，但是执行顺序会根据发出请求顺序执行。

#### async和defer(加载时都不会阻塞渲染引擎(与普通script差异特点))

async异步执行:哪个js脚本加载到就会立刻执行。

defer延迟执行：会在页面dom与css加载解析，且所有css资源加载后，按照顺序执行js。

总结:所有script顺序放在\<body>结束标签之上与所有script加上defer表现一致。90%的业务情况都用不到async，因为加载到后阻塞渲染引擎，导致页面白屏。



